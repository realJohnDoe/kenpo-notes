<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>{{TITLE}}</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #fafafa;
      }
      svg {
        width: 100%;
        height: 100vh;
        display: block;
      }
      .txt {
        font-family: sans-serif;
        font-size: 1rem; /* Decreased font size for clock labels */
        fill: black;
      }
      #stepLabel {
        font-family: sans-serif;
        font-size: 1.5rem; /* Original size for YAML labels */
        fill: black;
      }
    </style>
  </head>
  <body>
    <!-- SVG placeholder â€“ the generator will inject shapes/text here -->
    {{SVG_CONTENT}}

    <div id="controls" style="position: fixed; bottom: 20px; right: 20px;">
      <button id="prevBtn">Prev</button>
      <button id="playPauseBtn">Pause</button>
      <button id="nextBtn">Next</button>
    </div>

    <script src="./anime.js"></script>
    <script>
      // Timeline data is injected by the generator
      const timelineData = {{TIMELINE_JSON}};
      const labelEl = document.getElementById('stepLabel');

      const mainTl = anime.timeline({autoplay:true, loop:false});

      let stepStartTimes = []; // To store the start time of each step
      let currentStepIndex = 0;
      let currentTimelineCursor = 0; // Tracks the end of the previous step's animations

      timelineData.forEach((step, index) => {
        stepStartTimes.push(currentTimelineCursor); // Store start time of this step

        let stepDuration = 1000; // Default duration for person animations

        // Add person animations to the main timeline
        if (step.anims && step.anims.length > 0) {
          const firstAnimation = step.anims[0];
          stepDuration = firstAnimation.duration;
          mainTl.add(firstAnimation, currentTimelineCursor);
          for (let i = 1; i < step.anims.length; i++) {
            mainTl.add(step.anims[i], currentTimelineCursor);
          }
        }

        // Add label animations to the main timeline
        if (step.label && step.label.texts && step.label.texts.length > 0) {
          const timePerLabel = stepDuration / step.label.texts.length;
          const fadeDuration = 200;

          // Set position and text, then fade in for the first label
          mainTl.add({
            targets: labelEl,
            translateY: step.label.y,
            duration: 1,
            begin: () => { labelEl.textContent = step.label.texts[0]; }
          }, currentTimelineCursor);

          mainTl.add({
            targets: labelEl,
            opacity: 1,
            duration: fadeDuration,
            easing: 'linear'
          }, currentTimelineCursor);

          // Loop through subsequent labels for the current step
          for (let i = 1; i < step.label.texts.length; i++) {
            const labelText = step.label.texts[i];
            const prevLabelStartTime = currentTimelineCursor + (i * timePerLabel);

            // Fade out previous label
            mainTl.add({
              targets: labelEl,
              opacity: 0,
              duration: fadeDuration,
              easing: 'linear',
              complete: () => { labelEl.textContent = labelText; }
            }, prevLabelStartTime - fadeDuration);

            // Fade in new label
            mainTl.add({
              targets: labelEl,
              opacity: 1,
              duration: fadeDuration,
              easing: 'linear'
            }, prevLabelStartTime);
          }
        }

        // After all animations for a step, fade out the last label
        mainTl.add({
            targets: labelEl,
            opacity: 0,
            duration: 200,
            easing: 'linear'
        }, currentTimelineCursor + stepDuration - 200);

        currentTimelineCursor += stepDuration; // Advance the timeline for the next step
      });
      // Add the end time of the last step
      stepStartTimes.push(currentTimelineCursor);


      // Control functions
      function goToStep(index) {
        const currentPlayTime = mainTl.currentTime;
        let targetTime;

        if (index >= 0 && index < stepStartTimes.length - 1) {
          targetTime = stepStartTimes[index];
        } else if (index === stepStartTimes.length - 1) { // Handle going to the very end
            targetTime = mainTl.duration;
        } else {
            return; // Invalid index
        }

        const duration = Math.abs(targetTime - currentPlayTime);

        anime({
            targets: mainTl,
            currentTime: targetTime,
            duration: duration * 0.1, // A fast animation, 10% of the actual time difference
            easing: 'linear',
            update: () => {
              mainTl.seek(mainTl.currentTime);
            },
            complete: () => {
              currentStepIndex = index;
              if (!mainTl.paused) {
                mainTl.pause();
                playPauseBtn.textContent = 'Play';
              }
            }
        });
      }

      const prevBtn = document.getElementById('prevBtn');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const nextBtn = document.getElementById('nextBtn');

      playPauseBtn.addEventListener('click', () => {
        if (mainTl.paused) {
          mainTl.play();
          playPauseBtn.textContent = 'Pause';
        } else {
          mainTl.pause();
          playPauseBtn.textContent = 'Play';
        }
      });

      prevBtn.addEventListener('click', () => {
        goToStep(currentStepIndex - 1);
      });

      nextBtn.addEventListener('click', () => {
        goToStep(currentStepIndex + 1);
      });

      // Initial state
      mainTl.pause(); // Start paused
      playPauseBtn.textContent = 'Play';
      goToStep(0); // Go to the first step
    </script>
  </body>
</html>
